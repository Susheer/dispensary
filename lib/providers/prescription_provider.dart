import 'dart:async';

import 'package:dispensary/appConfig.dart';
import 'package:dispensary/models/medicine_model.dart';
import 'package:dispensary/models/prescription_line_model.dart';
import 'package:dispensary/models/prescription_model.dart';
import 'package:dispensary/services/database_service.dart';
import 'package:dispensary/services/fake_prescription_generator.dart';
import 'package:dispensary/utils.dart/util.dart';
import 'package:flutter/material.dart';

class PrescriptionProvider extends ChangeNotifier {
  final DatabaseService _databaseService;
  List<Prescription> _prescriptionList = [];
  int dbCount = 0;
  PrescriptionProvider(this._databaseService);
  List<Prescription> get getPrescriptionList => _prescriptionList;

  Future<void> storePrescriptionAndLines(Prescription prescription) async {
    // Start the transaction
    await _databaseService.db.transaction((txn) async {
      try {
        // Remove sysPrescriptionId as it will be auto-generated by the database
        final Map<String, dynamic> prescriptionWithoutId = prescription.toMapIgnoreSysId();

        final List<Map<String, dynamic>> listOfLines = prescriptionWithoutId['prescription_lines'];

        prescriptionWithoutId.remove('prescription_lines');
        // Store Prescription data
        await txn.insert('prescriptions', prescriptionWithoutId);

        // Retrieve the sysPrescriptionId of the inserted prescription
        final prescriptionId = await txn.query('prescriptions', orderBy: 'sys_prescription_id DESC', limit: 1);
        if (prescriptionId.isNotEmpty) {
          final sysPrescriptionId = prescriptionId.first['sys_prescription_id'] as int;

          // Store PrescriptionLine data
          for (final Map<String, dynamic> line in listOfLines) {
            line['medicine_id'] = line['medicine']['sys_medicine_id'];
            line.remove('medicine');
            // Set the sysPrescriptionId of the related prescription
            line['prescription_id'] = sysPrescriptionId;
            // Store PrescriptionLine data
            await txn.insert('prescription_line', line);
          }
        }
        int timestamp = convertISODateStringToUnixTimestampInSeconds(DateTime.now().toIso8601String());
        // below update is to keep track of follow up counts
        await txn.update(
          'patients',
          {'updated_date': timestamp},
          where: 'id=?',
          whereArgs: [prescription.patientId],
        );
      } catch (error) {
        // If an error occurs, the transaction will be rolled back
        print('Error storing prescription and lines: $error');
        rethrow; // Rethrow the error to let the caller handle it
      }
    });
  }

  Future<List<Prescription>> getPrescriptionsByPatientIdWithDetails(int patientId, {int pageNum = 0, int pageSize = AppConfig.PrescriptionSize}) async {
    final List<Map<String, dynamic>> prescriptionsData = await _databaseService.db.query(
      'prescriptions',
      where: 'patient_id = ?',
      orderBy: "created_date DESC",
      offset: pageNum * pageSize,
      limit: pageSize,
      whereArgs: [patientId],
    );

    List<Prescription> prescriptions = [];
    for (final Map<String, dynamic> prescriptionData in prescriptionsData) {
      Prescription prescription = Prescription.fromMap(prescriptionData);
      int sysPrescriptionId = prescription.sysPrescriptionId;
      final List<Map<String, dynamic>> prescriptionLinesData = await _databaseService.db.query(
        'prescription_line',
        where: 'prescription_id = ?',
        whereArgs: [sysPrescriptionId],
      );
      List<int> sysIdOfBadLines = [];
      for (final Map<String, dynamic> lineData in prescriptionLinesData) {
        final Medicine? medicine = await getMedicineById(lineData['medicine_id'] as int);
        if (medicine != null) {
          PrescriptionLine line = PrescriptionLine(
              sysPrescriptionLineId: lineData['sys_prescription_line_id'],
              medicine: medicine!, // won't be null
              doses: lineData['doses'],
              duration: lineData['duration'],
              notes: lineData['notes'],
              strength: lineData['strength']);
          prescription.prescriptionLines.add(line);
        } else {
          // @todo
          // medicine is null;
          // do not consider this line, try remove all such lines from db;
          sysIdOfBadLines.add(lineData['sys_prescription_line_id']);
        }
      }
      prescriptions.add(prescription);
    }
    return prescriptions;
  }

  Future<Medicine?> getMedicineById(int sysMedicineId) async {
    List<Map<String, dynamic>> results = await _databaseService.db.query(
      'medicines',
      where: 'sys_medicine_id = ?',
      whereArgs: [sysMedicineId],
    );
    // Check if the results list is not empty
    if (results.isNotEmpty) {
      // Convert the result to a Patient object
      return Medicine.fromMap(results.first);
    }
  }

  Future<void> addFakePrescriptions(int patientId) async {
    Prescription fakePrescription = await FakePrescriptionGenerator.generateFakePrescription(patientId);
    await storePrescriptionAndLines(fakePrescription);
    dbCount++;
    notifyListeners();
  }

  Future<void> initPrescriptionList(int patientId) async {
    List<Prescription> list = await getPrescriptionsByPatientIdWithDetails(patientId);
    _prescriptionList = list;
    notifyListeners();
  }

  Future<List<Prescription>> loadNextPage(int patientId, int pageNumber) async {
    List<Prescription> list = await getPrescriptionsByPatientIdWithDetails(patientId, pageNum: pageNumber, pageSize: AppConfig.PrescriptionSize);
    return list;
  }

  Future<void> inItPrescriptionScreen(int patientId) async {
    List<Prescription> list = await getPrescriptionsByPatientIdWithDetails(patientId);
    final List<Map<String, dynamic>> result = await _databaseService.db.query(
      'prescriptions',
      columns: ['COUNT(*) as count'],
      where: 'patient_id = ?',
      whereArgs: [patientId],
    );

    final count = result.firstWhere((map) => true)['count'] as int?;
    dbCount = count ?? 0;
    _prescriptionList = list;
    notifyListeners();
  }
}
